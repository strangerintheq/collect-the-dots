<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <script>

        (function() {

            window.maps = [level1(), level2(), level3()];

            function level1() {
                return `
                xxxxxxxxxxxxxxxxxxxxxx
                x.........x..........x
                x.       .x.        .x
                x.       .x.        .x
                x.       .x.        .x
                x.       .x.        .x
                x....................x
                xs       .x.        xx
                x        .x.        ex
                x        .x.        .x
                x        .x.        .x
                x        .x.        .x
                x p.......x..........x
                xxxxxxxxxxxxxxxxxxxxxx
            `;
            }

            function level2() {
                return `
                xxxxxxxxxxxxxxxxxxxxxx
                x.........x..........x
                x.       .x.        .x
                x.       .x.        .x
                x.       .x.        .x
                x.       .s.        .x
                x....................x
                xx       .s.        xx
                x        .x.        px
                x        .x.        .x
                x        .x.        .x
                x        .x.        .x
                xe........x..........x
                xxxxxxxxxxxxxxxxxxxxxx
            `;
            }

            function level3() {
                return `
                xxxxxxxxxxxsxxxxxxxxxxx
                s.....................x
                x.       s.x.        .x
                x.        .x.        .x
                x.        .x.        .x
                x.        .x.        .x
                x.........xx.        .x
                xs        ex.        .x
                x         .x.        .x
                x         .x.        .x
                x         .x.        .x
                x         .x.        .x
                x..........x.        .x
                xxxxxxsxxxxx.        .x
                xxxxxxxxxxxx.        .x
                xx.........x.        .x
                x.        .x.        .x
                x.        .x.        .x
                x.        .x.        .x
                x.        .x.        .x
                x..........x.        xx
                x s       sx.        .x
                x         .x.        .x
                x         .x.        .x
                x         .x.        .x
                x         .x.        .x
                x p..........        .s
                xxxxxxsxxxxxxxxxxxxxxxx
            `
            }

        })();

        class Cell {
            constructor(x, y, type, game, color, size) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.renderSize = size;
                this.state = 0;
                this.neighbors = [];
                this.game = game;
            }

            tick() {}

            activate() {
                this.neighbors.forEach(neighbor =>
                    neighbor.activateByNeighbor(this.x, this.y));
            }

            activateByNeighbor(){}

            renderCell(renderer, context) {
                renderer.drawRect(this.x, this.y,
                    this.renderSize, this.color, context);
            }
        }

        class Coin extends Cell {
            constructor(x, y, type, game) {
                super(x, y, type, game, '#ffe15a', 0.3);
                this.active = true;
            }

            activate() {
                super.activate();
                if (!this.active) return;
                this.state = 10;
                this.active = false
            }

            tick() {
                if (!this.state) return;
                this.renderSize = 0.3*(this.state -= 0.2)/10;
                if (this.state <= 0) this.state = 0;
            }
        }

        class Exit extends Cell {
            constructor(x, y, type, game) {
                super(x, y, type, game, '#ff8882', 0.6);
            }

            activate() {
                this.game.nextLevel();
            }
        }

        class Wall extends Cell {
            constructor(x, y, type, game) {
                super(x, y, type, game, '#876040', 1.01);
                this.isWall = true;
                this.isStatic = true;
            }

            renderCell(renderer, context) {
                context.fillStyle = this.color;
                let s = renderer.size;

                this.neighbors.forEach(n => {
                    if (n.isWall) {

                        return;
                    }

                    context.fillRect(
                        this.x*s + (this.x===n.x?s/3:this.x>n.x?0:2*s/3),
                        this.y*s + (this.y===n.y?s/3:this.y>n.y?0:2*s/3),
                        s/3,s/3)
                });

                context.fillRect(this.x*s, this.y*s, s/3,s/3)
                context.fillRect(this.x*s+s/3*2, this.y*s, s/3,s/3)
                context.fillRect(this.x*s, this.y*s+s/3*2, s/3,s/3)
                context.fillRect(this.x*s+s/3*2, this.y*s+s/3*2, s/3,s/3)
            }
        }

        class Spike extends Wall {
            constructor(x, y, type, game) {
                super(x, y, type, game);
                this.isStatic = false;
                this.color = '#61c0ff'
            }

            activateByNeighbor(x,y) {
                if (this.state)
                    return;
                this.state = 10;
                this.activatedByCell = [x,y];
            }

            tick() {
                if (!this.state)
                    return;
                this.state -= 0.1;
                if (this.state <= 0) {
                    if (this.isActive) {
                        this.isActive = false;
                        this.state = 0;
                    } else  {
                        this.isActive = true;
                        this.state = 10;
                    }
                }
            }

            renderCell(renderer, context) {
                super.renderCell(renderer, context)
                if(this.isActive) {
                    renderer.drawRect(
                        this.activatedByCell[0],
                        this.activatedByCell[1],
                        1, this.color)
                }
            }

        }

        class CanvasRenderer {
            constructor() {
                this.createRendererComponent();
                document.body.append(this.canvas);
                document.body.style.background = "#000";
                document.body.style.overflow = "hidden";
                this.resizeRenderer();
            }

            createRendererComponent() {
                this.canvas = document.createElement('canvas');
                this.ctx = this.canvas.getContext('2d');
            }

            resizeRenderer() {
                this.canvas.width = innerWidth;
                this.canvas.height = innerHeight;
                this.size = Math.round(Math.min(innerWidth, innerHeight)/30);
            }

            updateStaticImage(level) {
                level.staticImage.width = level.width*this.size;
                level.staticImage.height = level.height*this.size;
                let ctx = level.staticImage.getContext("2d");
                level.iterateCells(c => c.isStatic && c.renderCell(this, ctx));
            }

            drawRect(x, y, s, color, context) {
                context = context || this.ctx;
                s = s * this.size;
                let shift = (this.size-s)/2;
                x = x*this.size + shift;
                y = y*this.size + shift;

                context.fillStyle = color;
                context.fillRect(x, y, s, s);
            }

            drawFrame(player, level) {
                this.ctx.clearRect(-1e9,-1e9,2e9,2e9);
                this.ctx.save();
                let cx = player.renderPosition[0]*this.size;
                let cy = player.renderPosition[1]*this.size;
                this.ctx.translate(innerWidth/2 - cx, innerHeight/2 - cy);
                this.ctx.drawImage(level.staticImage, 0, 0);
                level.iterateCells(c => !c.isStatic && c.renderCell(this, this.ctx));
                player.renderCell(this, this.ctx);
                this.ctx.restore();
            }
        }

        class TouchControls {
            constructor(player) {
                document.addEventListener('touchstart', handleTouchStart, false);
                document.addEventListener('touchmove', handleTouchMove, false);

                var xDown = null;
                var yDown = null;

                function handleTouchStart(evt) {
                    xDown = evt.touches[0].clientX;
                    yDown = evt.touches[0].clientY;
                }

                function handleTouchMove(evt) {
                    if ( ! xDown || ! yDown )
                        return;
                    var xUp = evt.touches[0].clientX;
                    var yUp = evt.touches[0].clientY;
                    var xDiff = xDown - xUp;
                    var yDiff = yDown - yUp;
                    if ( Math.abs( xDiff ) > Math.abs( yDiff ) )
                        player.move(0,-Math.sign(xDiff));
                    else
                        player.move(-Math.sign(yDiff), 0);
                    xDown = null;
                    yDown = null;
                    evt.preventDefault()
                }
            }
        }

        class KeyboardControls {
            constructor(player) {
                addEventListener('keydown', e => {
                    e.keyCode === 65 && player.move(0, -1);
                    e.keyCode === 68 && player.move(0, 1);
                    e.keyCode === 87 && player.move(-1, 0);
                    e.keyCode === 83 && player.move(1, 0);
                });
            }
        }

        class Level {
            constructor(src, game) {
                this.cells = {
                    'x': Wall,
                    's': Spike,
                    '.': Coin,
                    'e': Exit
                };
                this.neighbors = [[-1,0],[1,0],[0,-1],[0,1]];
                this.map = src.trim()
                    .split('\n')
                    .map((row, y) =>
                        row.trim()
                            .split('')
                            .map((type, x) => this.createCell(type,x,y, game)));
                this.iterateCells(c => {
                    this.neighbors.forEach(xy => {
                        try {
                            this.map[c.y + xy[1]][c.x + xy[0]].neighbors.push(c);
                        } catch (e) {}
                    })
                });
                this.height = this.map.length;
                this.width = Math.max(...this.map.map(r => r.length));
                this.staticImage = document.createElement("canvas");

            }

            iterateCells(f) {
                this.map.forEach(r => r.forEach(c => c && f(c)));
            }

            createCell(type, x, y, game) {
                if (type === 'p') this.playerEnter = [x, y];
                return new (this.cells[type] || Cell)(x, y, type, game);
            }
        }

        class Player {
            constructor() {
                this.logicPosition = null;
            }

            lerp(a, b, t) {
                return a + t*(b-a);
            }

            renderCell(renderer){
                renderer.drawRect(...this.renderPosition, this.renderSize, "wheat")
            }

            calcPlayerPosition(t) {
                this.renderPosition = [...this.logicPosition];
                this.renderSize = 1;

                if (!this.moveToPosition)
                    return;

                if (!this.moveStartTime) {
                    this.moveStartTime = t;
                    this.moveDuration = Math.abs(
                        this.logicPosition[0] + this.logicPosition[1] -
                        this.moveToPosition[0] - this.moveToPosition[1]
                    )*25;
                }

                let dt = (t - this.moveStartTime)/this.moveDuration;
                if (dt > 1) {
                    this.logicPosition = [...this.moveToPosition];
                    this.renderPosition = [...this.moveToPosition];
                    this.moveToPosition = null;
                    this.moveDuration = this.moveStartTime = 0;
                } else if (dt) {
                    this.renderPosition[0] = this.lerp(
                        this.logicPosition[0], this.moveToPosition[0], dt);
                    this.renderPosition[1] = this.lerp(
                        this.logicPosition[1], this.moveToPosition[1], dt);
                    this.renderSize = 0.8;
                }
            }

            move(dirx, diry){
                if (this.moveToPosition)
                    return;
                let mt = this.moveToPosition = [...this.logicPosition];
                for (let i=0; i<99; i++) {
                    let next = this.levelMap[mt[1]+dirx][mt[0]+diry];
                    if (next.isWall)
                        break;
                    mt[1] += dirx;
                    mt[0] += diry;
                }
            }

            enterToLevel(level) {
                this.logicPosition = level.playerEnter;
                this.levelMap = level.map;
            }
        }

        class CollectTheDotsGame {
            constructor() {
                this.levelIndex = 0;
                this.renderer = new CanvasRenderer();
                this.player = new Player();

                new KeyboardControls(this.player);
                new TouchControls(this.player);

                this.nextLevel();

                addEventListener('resize', e => {
                    this.renderer.resizeRenderer();
                    this.renderer.updateStaticImage(this.level);
                });

                setInterval(this.gameLogic.bind(this), 10);
                this.gameLogic();
                this.drawFrame();
            }

            gameLogic() {
                this.level.iterateCells(c => c.tick());
                this.player.calcPlayerPosition(Date.now());
                let cx = Math.round(this.player.renderPosition[0]);
                let cy = Math.round(this.player.renderPosition[1]);
                this.level.map[cy][cx].activate();
            }

            drawFrame() {
                requestAnimationFrame(this.drawFrame.bind(this));
                this.renderer.drawFrame(this.player, this.level);
            }

            nextLevel() {
                this.level = new Level(maps[this.levelIndex], this);
                this.renderer.updateStaticImage(this.level);
                this.player.enterToLevel(this.level);
                this.levelIndex++;
                if (this.levelIndex === maps.length)
                    this.levelIndex = 0;
            }
        }

        new CollectTheDotsGame();

    </script>
</body>
</html>